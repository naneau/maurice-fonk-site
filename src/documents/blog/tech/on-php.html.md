---
title: "On PHP"
layout: "blog"
isPage: true
---
# On PHP

A decent amount of my income still comes from writing PHP. It is shameful, I
know. Save for a few hardcore, unapologetic fanboys, most people I know see the
language as a necessary evil at best, but more likely as *expletive deleted*.
[And it is
true](http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/), PHP
is a poorly thought out, pretty outdated, designed-by-committee, inconsistent
heap of yet another expletive.

There are more poor languages in heavy use today, JavaScript being a prime
example. While being impossible to avoid in the browser, it has also made the
leap to the server. [Node](http://nodejs.org/) now powers some of the largest
web applications around. All based on JavaScript.

## Ecosystems

JavaScript is different from PHP though. JavaScript is a language one person
did [not think about nearly
enough](https://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript),
while PHP is a language too many people thought about too much. But that is the
language itself. It is easy to focus on that, but by comparing a language in
isolation you miss part of the story. Node is popular, in a way, because it is
popular. Popularity and a decent package manager combine into a welcoming
ecosystem of friendly libraries and tools.

PHP applications written after the advent of
[Composer](https://getcomposer.org/) are certainly more manageable than those
that came before. Writing PHP code isn't so bad nowadays, either. You can
definitely avoid some of the bad parts of the language, and when combined with
a decent framework, the whole experience can be downright decent.

## Flawed Languages

The point being, PHP and JavaScript together touch a large part of all web
applications, both in the browser and on the server. These languages are
severely flawed, yet new applications are constantly being developed in both.
It makes you wonder if the quality of a language matters at all.

Surely it is true that our natural languages aren't perfect. They are imprecise
and irregular. [Alternatives exist](http://en.wikipedia.org/wiki/Esperanto),
but are not often sought out. Maybe we do not care about imperfections, once we
understand them. I can obviously communicate with you in English, and get my
point across just as well as I could in Esperanto (were I to actually speak
it).

## Beautiful Languages

I love functional languages, their elegance and conciseness make coding in them
feel like less of a chore. No matter how much I love Haskell, however, it is
not the tool I'd use for powering a web application, if I had to start writing
one tomorrow. It might be, in the future, but I have neither the time, nor the
energy to spearhead that fight. I have problems to solve, code to write,
deadlines to meet.

A beautiful language helps you write beautiful code. Code beauty is not what my
clients pay for, though, they tend to care about silly things like usability,
performance and price. Sure, beautiful code is easier to maintain, which is a
real requirement. Maintainability can also be attained with decent tools,
standards, and experience, however. End users do not know, let alone care,
about the languages and tools used to create the applications they use. The
incentives trickling down from their level are limited to providing tangible
improvements to their experience. As long as one tool set can deliver the same
experienced quality as another, comparisons tend to end up in flame wars.

## Reinforcements

I get paid to write PHP. I'm not the only one. It is what others use, and
therefore it is what I must use. What with teamwork and such.

There is an "ecosystem", and it votes for PHP through employers' wallets.  Good
developers are scarce, and they seem to like being divided into language based
cliques. An employer looking for a new hire will focus on specific skills,
matching that of his current employees, thereby reinforcing its current
structure. Actually *changing* your tool set, at least in an organizational
setting, is usually quite out of reach.

## Greatness

Great developers transcend cliques. They understand the parallels between tool
sets. They grok abstraction layers, using intricacies from one the next level
up. In my experience, they also tend to complain less about imperfect tools.
When confronted with poor design they'll say "that is stupid", then simply work
around it.

Then again, great developers are rare in the PHP world...
